<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programming on amar</title><link>https://amarjandu.github.io/tags/programming/</link><description>Recent content in Programming on amar</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 14 Feb 2025 09:18:51 -0800</lastBuildDate><atom:link href="https://amarjandu.github.io/tags/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>AWS IAM for Logging</title><link>https://amarjandu.github.io/posts/aws-iam-logging/</link><pubDate>Fri, 14 Feb 2025 09:18:51 -0800</pubDate><guid>https://amarjandu.github.io/posts/aws-iam-logging/</guid><description>History The saying goes that developer documentation is full of lies (the words of the great xbrianh). The longer I work with Cloud Platforms the more I realize this is true, and that there are strange inconsistencies within the API.
In the case of AWS, you use IAM policies to allow/disallow access to resources/actions between you internal infrastructure. e.g.
{ &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [{ &amp;#34;Sid&amp;#34;: &amp;#34;AllowLambdaInvocation&amp;#34;, &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;lambda:InvokeFunction&amp;#34;, &amp;#34;lambda:InvokeAsync&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;arn:aws:lambda:*:*:function:*&amp;#34; }] } For the most part these are manually managed, when you want to use a resource, you have to define the policy that</description></item><item><title>doctests</title><link>https://amarjandu.github.io/posts/doctests/</link><pubDate>Mon, 28 Feb 2022 18:48:23 -0800</pubDate><guid>https://amarjandu.github.io/posts/doctests/</guid><description>Consider some small function such as:
def parse_string(input: str): try: name, value = input.split(&amp;#39;:&amp;#39;) except ValueError: name = input value = None assert name, input return name, value These utility functions typically have a small footprint, yet there can be dozens of them scattered in a codebase. Testing them directly within the test suite can be done, but if you start adding multiple files for multiple utility functions, the disassociation between proximity of definition and location of tests make it annoying to maintain.</description></item></channel></rss>